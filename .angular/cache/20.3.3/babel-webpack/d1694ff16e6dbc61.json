{"ast":null,"code":"import { BehaviorSubject, of, throwError, timer } from 'rxjs';\nimport { catchError, map, switchMap, tap, finalize } from 'rxjs/operators';\nimport { hasPermission, hasRole } from '../models/auth.model';\nimport { API_ENDPOINTS } from '../constants/api-endpoints';\nimport { environment } from '../../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./api.service\";\nimport * as i2 from \"@angular/router\";\nexport let AuthService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class AuthService {\n    // Getters for current values\n    get currentUser() {\n      return this.currentUserSubject.value;\n    }\n    get isAuthenticated() {\n      return this.isAuthenticatedSubject.value;\n    }\n    constructor(apiService, router) {\n      this.apiService = apiService;\n      this.router = router;\n      // State management\n      this.currentUserSubject = new BehaviorSubject(this.loadStoredUser());\n      this.isAuthenticatedSubject = new BehaviorSubject(this.checkInitialAuth());\n      this.loadingSubject = new BehaviorSubject(false);\n      // Public observables\n      this.currentUser$ = this.currentUserSubject.asObservable();\n      this.isAuthenticated$ = this.isAuthenticatedSubject.asObservable();\n      this.loading$ = this.loadingSubject.asObservable();\n      // Initialize session monitoring if authenticated\n      if (this.isAuthenticated) {\n        this.startSessionMonitoring();\n        this.validateToken();\n      }\n    }\n    /**\n     * Load stored user from localStorage\n     */\n    loadStoredUser() {\n      if (typeof window === 'undefined') return null;\n      const storedUser = localStorage.getItem('current_user');\n      if (storedUser) {\n        try {\n          return JSON.parse(storedUser);\n        } catch (error) {\n          console.error('Failed to parse stored user:', error);\n          localStorage.removeItem('current_user');\n        }\n      }\n      return null;\n    }\n    /**\n     * Check initial authentication status\n     */\n    checkInitialAuth() {\n      return !!this.apiService.currentToken && !!this.loadStoredUser();\n    }\n    /**\n     * User login\n     */\n    login(credentials) {\n      this.loadingSubject.next(true);\n      // Mock login implementation for demo purposes\n      return timer(1000).pipe(\n      // Simulate network delay\n      map(() => {\n        // Mock user data based on credentials\n        const mockUsers = {\n          'admin@ihub.com': {\n            id: '1',\n            email: 'admin@ihub.com',\n            fullName: 'Admin User',\n            role: 'admin',\n            organizationId: 'org-1',\n            isActive: true,\n            emailVerified: true,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            lastLogin: new Date().toISOString(),\n            permissions: ['*']\n          },\n          'inspector@ihub.com': {\n            id: '2',\n            email: 'inspector@ihub.com',\n            fullName: 'Inspector User',\n            role: 'inspector',\n            organizationId: 'org-1',\n            isActive: true,\n            emailVerified: true,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            lastLogin: new Date().toISOString(),\n            permissions: ['inspections:read', 'inspections:write', 'defects:read', 'defects:write']\n          },\n          'viewer@ihub.com': {\n            id: '3',\n            email: 'viewer@ihub.com',\n            fullName: 'Viewer User',\n            role: 'viewer',\n            organizationId: 'org-1',\n            isActive: true,\n            emailVerified: true,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            lastLogin: new Date().toISOString(),\n            permissions: ['inspections:read', 'defects:read']\n          }\n        };\n        const user = mockUsers[credentials.email];\n        if (!user) {\n          throw new Error('Invalid email or password');\n        }\n        // Check password (simple mock - in real app this would be hashed)\n        const validPasswords = {\n          'admin@ihub.com': 'Admin@123',\n          'inspector@ihub.com': 'Inspector@123',\n          'viewer@ihub.com': 'Viewer@123'\n        };\n        if (credentials.password !== validPasswords[credentials.email]) {\n          throw new Error('Invalid email or password');\n        }\n        // Mock JWT tokens\n        const mockAccessToken = `mock-jwt-token-${user.id}-${Date.now()}`;\n        const mockRefreshToken = `mock-refresh-token-${user.id}-${Date.now()}`;\n        const loginResponse = {\n          user,\n          accessToken: mockAccessToken,\n          refreshToken: mockRefreshToken,\n          tokenType: 'Bearer',\n          expiresIn: 3600 // 1 hour\n        };\n        return loginResponse;\n      }), tap(loginResponse => {\n        // Store tokens\n        this.apiService.setToken(loginResponse.accessToken);\n        localStorage.setItem(environment.refreshTokenKey, loginResponse.refreshToken);\n        // Store user\n        this.storeUser(loginResponse.user);\n        // Update state\n        this.currentUserSubject.next(loginResponse.user);\n        this.isAuthenticatedSubject.next(true);\n        // Start session monitoring\n        this.startSessionMonitoring();\n        // Handle remember me\n        if (credentials.rememberMe) {\n          localStorage.setItem('remember_me', 'true');\n        }\n      }), catchError(error => {\n        this.handleAuthError(error);\n        return throwError(() => error);\n      }), finalize(() => this.loadingSubject.next(false)));\n    }\n    /**\n     * User registration\n     */\n    register(userData) {\n      this.loadingSubject.next(true);\n      return this.apiService.post(API_ENDPOINTS.AUTH.REGISTER, userData).pipe(map(response => response.data), tap(registerResponse => {\n        // If tokens are provided, auto-login\n        if (registerResponse.accessToken && registerResponse.refreshToken) {\n          this.apiService.setToken(registerResponse.accessToken);\n          localStorage.setItem(environment.refreshTokenKey, registerResponse.refreshToken);\n          this.storeUser(registerResponse.user);\n          this.currentUserSubject.next(registerResponse.user);\n          this.isAuthenticatedSubject.next(true);\n          this.startSessionMonitoring();\n        }\n      }), catchError(error => {\n        this.handleAuthError(error);\n        return throwError(() => error);\n      }), finalize(() => this.loadingSubject.next(false)));\n    }\n    /**\n     * User logout\n     */\n    logout(redirectToLogin = true) {\n      this.loadingSubject.next(true);\n      // Call logout endpoint (optional, to invalidate token on server)\n      const logoutRequest = this.apiService.currentToken ? this.apiService.post(API_ENDPOINTS.AUTH.LOGOUT, {}) : of(null);\n      return logoutRequest.pipe(tap(() => {\n        this.clearAuthData();\n        if (redirectToLogin) {\n          this.router.navigate(['/auth/login']);\n        }\n      }), catchError(() => {\n        // Clear data even if logout request fails\n        this.clearAuthData();\n        if (redirectToLogin) {\n          this.router.navigate(['/auth/login']);\n        }\n        return of(null);\n      }), finalize(() => this.loadingSubject.next(false)));\n    }\n    /**\n     * Refresh access token\n     */\n    refreshToken() {\n      const refreshToken = localStorage.getItem(environment.refreshTokenKey);\n      if (!refreshToken) {\n        return throwError(() => new Error('No refresh token available'));\n      }\n      return this.apiService.post(API_ENDPOINTS.AUTH.REFRESH_TOKEN, {\n        refreshToken\n      }).pipe(map(response => response.data), tap(tokenResponse => {\n        this.apiService.setToken(tokenResponse.accessToken);\n        localStorage.setItem(environment.refreshTokenKey, tokenResponse.refreshToken);\n      }), catchError(error => {\n        this.clearAuthData();\n        this.router.navigate(['/auth/login']);\n        return throwError(() => error);\n      }));\n    }\n    /**\n     * Forgot password\n     */\n    forgotPassword(request) {\n      return this.apiService.post(API_ENDPOINTS.AUTH.FORGOT_PASSWORD, request).pipe(map(response => response.data));\n    }\n    /**\n     * Reset password\n     */\n    resetPassword(request) {\n      return this.apiService.post(API_ENDPOINTS.AUTH.RESET_PASSWORD, request).pipe(map(response => response.data));\n    }\n    /**\n     * Change password\n     */\n    changePassword(request) {\n      return this.apiService.post(API_ENDPOINTS.AUTH.CHANGE_PASSWORD, request).pipe(map(response => response.data));\n    }\n    /**\n     * Verify email\n     */\n    verifyEmail(request) {\n      return this.apiService.post(API_ENDPOINTS.AUTH.VERIFY_EMAIL, request).pipe(map(response => response.data));\n    }\n    /**\n     * Get current user profile\n     */\n    getProfile() {\n      return this.apiService.get(API_ENDPOINTS.AUTH.PROFILE).pipe(map(response => response.data), tap(user => {\n        this.storeUser(user);\n        this.currentUserSubject.next(user);\n      }));\n    }\n    /**\n     * Update user profile\n     */\n    updateProfile(userData) {\n      return this.apiService.put(API_ENDPOINTS.AUTH.PROFILE, userData).pipe(map(response => response.data), tap(user => {\n        this.storeUser(user);\n        this.currentUserSubject.next(user);\n      }));\n    }\n    /**\n     * Validate current token\n     */\n    validateToken() {\n      if (!this.apiService.currentToken) {\n        return of(false);\n      }\n      // Mock token validation - just check if we have a stored user\n      return of(!!this.currentUser);\n    }\n    /**\n     * Check if user has permission\n     */\n    hasPermission(permission) {\n      return hasPermission(this.currentUser, permission);\n    }\n    /**\n     * Check if user has role\n     */\n    hasRole(roles) {\n      return hasRole(this.currentUser, roles);\n    }\n    /**\n     * Decode JWT token\n     */\n    decodeToken(token) {\n      const tokenToDecode = token || this.apiService.currentToken;\n      if (!tokenToDecode) return null;\n      try {\n        const base64Url = tokenToDecode.split('.')[1];\n        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n        const jsonPayload = decodeURIComponent(atob(base64).split('').map(function (c) {\n          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        }).join(''));\n        return JSON.parse(jsonPayload);\n      } catch (error) {\n        console.error('Failed to decode JWT token:', error);\n        return null;\n      }\n    }\n    /**\n     * Check if token is expired\n     */\n    isTokenExpired(token) {\n      // Treat mock tokens as non-expiring for local development\n      const tokenToCheck = token ?? this.apiService.currentToken ?? '';\n      if (tokenToCheck.startsWith('mock-')) {\n        return false;\n      }\n      const payload = this.decodeToken(tokenToCheck);\n      if (!payload || !payload.exp) return false;\n      const expirationDate = new Date(payload.exp * 1000);\n      return expirationDate <= new Date();\n    }\n    /**\n     * Get token expiration time in milliseconds\n     */\n    getTokenExpirationTime() {\n      const current = this.apiService.currentToken ?? '';\n      // Provide a default of 1 hour for mock tokens\n      if (current.startsWith('mock-')) {\n        return 60 * 60 * 1000;\n      }\n      const payload = this.decodeToken(current);\n      if (!payload || !payload.exp) return null;\n      return payload.exp * 1000 - Date.now();\n    }\n    /**\n     * Store user in localStorage\n     */\n    storeUser(user) {\n      localStorage.setItem('current_user', JSON.stringify(user));\n    }\n    /**\n     * Clear all auth data\n     */\n    clearAuthData() {\n      // Clear tokens\n      this.apiService.clearToken();\n      // Clear user data\n      localStorage.removeItem('current_user');\n      localStorage.removeItem('remember_me');\n      // Update state\n      this.currentUserSubject.next(null);\n      this.isAuthenticatedSubject.next(false);\n      // Stop session monitoring\n      this.stopSessionMonitoring();\n    }\n    /**\n     * Handle authentication errors\n     */\n    handleAuthError(error) {\n      console.error('Authentication error:', error);\n      if (error.status === 401) {\n        this.clearAuthData();\n      }\n    }\n    /**\n     * Start session monitoring\n     */\n    startSessionMonitoring() {\n      this.stopSessionMonitoring();\n      // Check token expiration periodically\n      this.sessionTimerSubscription = timer(0, 60000) // Check every minute\n      .pipe(switchMap(() => {\n        const expirationTime = this.getTokenExpirationTime();\n        if (!expirationTime) {\n          return of(false);\n        }\n        // Warn user 5 minutes before expiration\n        if (expirationTime <= environment.sessionWarning) {\n          console.warn('Session expiring soon');\n          // TODO: Show warning notification to user\n        }\n        // Auto-refresh token 2 minutes before expiration\n        if (expirationTime <= 120000) {\n          return this.refreshToken().pipe(map(() => true), catchError(() => of(false)));\n        }\n        return of(true);\n      })).subscribe(valid => {\n        if (!valid) {\n          this.logout();\n        }\n      });\n    }\n    /**\n     * Stop session monitoring\n     */\n    stopSessionMonitoring() {\n      if (this.sessionTimerSubscription) {\n        this.sessionTimerSubscription.unsubscribe();\n        this.sessionTimerSubscription = null;\n      }\n    }\n    /**\n     * Clean up on service destruction\n     */\n    ngOnDestroy() {\n      this.stopSessionMonitoring();\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function AuthService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AuthService)(i0.ɵɵinject(i1.ApiService), i0.ɵɵinject(i2.Router));\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AuthService,\n      factory: AuthService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return AuthService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}