{"ast":null,"code":"import { HttpHeaders } from '@angular/common/http';\nimport { BehaviorSubject, throwError } from 'rxjs';\nimport { catchError, tap } from 'rxjs/operators';\nimport { environment } from '../../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let ApiService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class ApiService {\n    constructor(http) {\n      this.http = http;\n      this.baseUrl = environment.apiUrl;\n      this.tokenSubject = new BehaviorSubject(this.getStoredToken());\n      this.loadingSubject = new BehaviorSubject(false);\n      this.loading$ = this.loadingSubject.asObservable();\n      this.token$ = this.tokenSubject.asObservable();\n    }\n    /**\n     * Get stored access token from localStorage\n     */\n    getStoredToken() {\n      if (typeof window !== 'undefined' && window.localStorage) {\n        return localStorage.getItem(environment.jwtTokenKey);\n      }\n      return null;\n    }\n    /**\n     * Set JWT access token\n     */\n    setToken(token) {\n      if (typeof window !== 'undefined' && window.localStorage) {\n        localStorage.setItem(environment.jwtTokenKey, token);\n        this.tokenSubject.next(token);\n      }\n    }\n    /**\n     * Clear JWT access token\n     */\n    clearToken() {\n      if (typeof window !== 'undefined' && window.localStorage) {\n        localStorage.removeItem(environment.jwtTokenKey);\n        localStorage.removeItem(environment.refreshTokenKey);\n        this.tokenSubject.next(null);\n      }\n    }\n    /**\n     * Get current token value\n     */\n    get currentToken() {\n      return this.tokenSubject.value;\n    }\n    /**\n     * Check if user is authenticated\n     */\n    get isAuthenticated() {\n      return !!this.currentToken;\n    }\n    /**\n     * Build HTTP headers with authentication\n     */\n    buildHeaders(customHeaders) {\n      let headers = new HttpHeaders({\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n      });\n      // Add authentication token if available\n      const token = this.currentToken;\n      if (token) {\n        headers = headers.set('Authorization', `Bearer ${token}`);\n      }\n      // Merge with custom headers if provided\n      if (customHeaders) {\n        if (customHeaders instanceof HttpHeaders) {\n          customHeaders.keys().forEach(key => {\n            const values = customHeaders.getAll(key);\n            if (values) {\n              headers = headers.delete(key);\n              values.forEach(value => {\n                headers = headers.append(key, value);\n              });\n            }\n          });\n        } else {\n          Object.keys(customHeaders).forEach(key => {\n            const value = customHeaders[key];\n            if (Array.isArray(value)) {\n              headers = headers.delete(key);\n              value.forEach(v => {\n                headers = headers.append(key, v);\n              });\n            } else {\n              headers = headers.set(key, value);\n            }\n          });\n        }\n      }\n      return headers;\n    }\n    /**\n     * Build request options\n     */\n    buildOptions(options) {\n      const headers = this.buildHeaders(options?.headers);\n      return {\n        headers,\n        params: options?.params,\n        withCredentials: options?.withCredentials || false\n      };\n    }\n    /**\n     * Handle HTTP errors\n     */\n    handleError(error) {\n      let errorMessage = 'An unknown error occurred';\n      if (error.error instanceof ErrorEvent) {\n        // Client-side error\n        errorMessage = `Client Error: ${error.error.message}`;\n      } else {\n        // Server-side error\n        if (error.status === 0) {\n          errorMessage = 'Network error. Please check your connection.';\n        } else if (error.status === 401) {\n          errorMessage = 'Unauthorized. Please login again.';\n          // Clear token on 401\n          this.clearToken();\n        } else if (error.status === 403) {\n          errorMessage = 'Access forbidden. You do not have permission.';\n        } else if (error.status === 404) {\n          errorMessage = 'Resource not found.';\n        } else if (error.status >= 500) {\n          errorMessage = 'Server error. Please try again later.';\n        } else if (error.error?.message) {\n          errorMessage = error.error.message;\n        } else {\n          errorMessage = `Server Error ${error.status}: ${error.statusText}`;\n        }\n      }\n      console.error('API Error:', errorMessage, error);\n      return throwError(() => new Error(errorMessage));\n    }\n    /**\n     * Generic GET request\n     */\n    get(endpoint, options) {\n      this.loadingSubject.next(true);\n      return this.http.get(`${this.baseUrl}${endpoint}`, this.buildOptions(options)).pipe(tap(() => this.loadingSubject.next(false)), catchError(error => {\n        this.loadingSubject.next(false);\n        return this.handleError(error);\n      }));\n    }\n    /**\n     * Generic POST request\n     */\n    post(endpoint, body, options) {\n      this.loadingSubject.next(true);\n      return this.http.post(`${this.baseUrl}${endpoint}`, body, this.buildOptions(options)).pipe(tap(() => this.loadingSubject.next(false)), catchError(error => {\n        this.loadingSubject.next(false);\n        return this.handleError(error);\n      }));\n    }\n    /**\n     * Generic PUT request\n     */\n    put(endpoint, body, options) {\n      this.loadingSubject.next(true);\n      return this.http.put(`${this.baseUrl}${endpoint}`, body, this.buildOptions(options)).pipe(tap(() => this.loadingSubject.next(false)), catchError(error => {\n        this.loadingSubject.next(false);\n        return this.handleError(error);\n      }));\n    }\n    /**\n     * Generic PATCH request\n     */\n    patch(endpoint, body, options) {\n      this.loadingSubject.next(true);\n      return this.http.patch(`${this.baseUrl}${endpoint}`, body, this.buildOptions(options)).pipe(tap(() => this.loadingSubject.next(false)), catchError(error => {\n        this.loadingSubject.next(false);\n        return this.handleError(error);\n      }));\n    }\n    /**\n     * Generic DELETE request\n     */\n    delete(endpoint, options) {\n      this.loadingSubject.next(true);\n      return this.http.delete(`${this.baseUrl}${endpoint}`, this.buildOptions(options)).pipe(tap(() => this.loadingSubject.next(false)), catchError(error => {\n        this.loadingSubject.next(false);\n        return this.handleError(error);\n      }));\n    }\n    /**\n     * File upload with progress tracking\n     */\n    uploadFile(endpoint, file, additionalData) {\n      const formData = new FormData();\n      formData.append('file', file, file.name);\n      // Append additional data if provided\n      if (additionalData) {\n        Object.keys(additionalData).forEach(key => {\n          if (additionalData[key] !== null && additionalData[key] !== undefined) {\n            formData.append(key, additionalData[key]);\n          }\n        });\n      }\n      // Build headers without Content-Type (let browser set it for multipart/form-data)\n      let headers = new HttpHeaders({\n        'Accept': 'application/json'\n      });\n      const token = this.currentToken;\n      if (token) {\n        headers = headers.set('Authorization', `Bearer ${token}`);\n      }\n      return this.http.post(`${this.baseUrl}${endpoint}`, formData, {\n        headers,\n        reportProgress: true,\n        observe: 'events'\n      }).pipe(catchError(this.handleError));\n    }\n    /**\n     * Multiple file upload\n     */\n    uploadMultipleFiles(endpoint, files, additionalData) {\n      const formData = new FormData();\n      files.forEach((file, index) => {\n        formData.append(`files`, file, file.name);\n      });\n      // Append additional data if provided\n      if (additionalData) {\n        Object.keys(additionalData).forEach(key => {\n          if (additionalData[key] !== null && additionalData[key] !== undefined) {\n            formData.append(key, additionalData[key]);\n          }\n        });\n      }\n      // Build headers without Content-Type\n      let headers = new HttpHeaders({\n        'Accept': 'application/json'\n      });\n      const token = this.currentToken;\n      if (token) {\n        headers = headers.set('Authorization', `Bearer ${token}`);\n      }\n      return this.http.post(`${this.baseUrl}${endpoint}`, formData, {\n        headers,\n        reportProgress: true,\n        observe: 'events'\n      }).pipe(catchError(this.handleError));\n    }\n    /**\n     * Download file from server\n     */\n    downloadFile(endpoint) {\n      return this.http.get(`${this.baseUrl}${endpoint}`, {\n        headers: this.buildHeaders(),\n        responseType: 'blob'\n      }).pipe(catchError(this.handleError));\n    }\n    /**\n     * Get request with text response\n     */\n    getText(endpoint) {\n      return this.http.get(`${this.baseUrl}${endpoint}`, {\n        headers: this.buildHeaders(),\n        responseType: 'text'\n      }).pipe(catchError(this.handleError));\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function ApiService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ApiService)(i0.ɵɵinject(i1.HttpClient));\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ApiService,\n      factory: ApiService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return ApiService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}